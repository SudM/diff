2. Define the canonical model for this use case
2.1 Subject

Add these to Model.Subject:

Model.Subject.type ‚Üí IB_USER, ADR_USER, BANKER, WHITE_LABEL_USER, ‚Ä¶

Model.Subject.tenancy ‚Üí INTERNET_BANKING, OPEN_BANKING, etc.

Model.Subject.channelAccessProfiles[] ‚Üí e.g. ["IB_WEB_ACCESS", "IB_MOBILE_ACCESS"]

Model.Subject.paymentAccessProfiles[] ‚Üí ["INTERBANK", "INTRABANK"]

These come from your token / directory / PIP, not from policies.

2.2 Payment

From previous answer, add at least:

Model.Payment.id

Model.Payment.type ‚Üí enum: INTERNATIONAL, TRANSFER, BPAY, LAT, REDRAW, MULTI_TRANSFER, PAYANYONE, ‚Ä¶

Model.Payment.debitAccountId

Model.Payment.creditAccountId (or external coords)

2.3 Account

Model.Account.id

Model.Account.ownerCustomerId

Model.Account.status ‚Üí ACTIVE, BLOCKED, CLOSED

Model.Account.channelVisibilityProfiles[] ‚Üí which access profiles can ‚Äúsee‚Äù this account (e.g. ["IB_WEB_ACCESS"])

2.4 Context

Model.Context.channel ‚Üí WEB, MOBILE, BRANCH, API

Model.Context.actionId ‚Üí canonical operation like PAYMENT_VIEW, PAYMENT_CREATE, PAYMENT_CANCEL, ACCT_VIEW etc.

2.5 Action mapping

Create a mapping layer so Action URI ‚Üí Context.actionId:

Examples:

action:payments/payment/view ‚Üí PAYMENT_VIEW

action:payments/payment/create ‚Üí PAYMENT_CREATE

action:payments/payment/cancel ‚Üí PAYMENT_CANCEL

action:acctmgmt/acctinfo/view ‚Üí ACCOUNT_VIEW

Do this once, in a derived attribute or processor, not in every policy.

3. Implement the model in PingAuthorize (data layer)
Step 1 ‚Äì Model namespace

In Attributes:

Add folder Model

Model ‚Üí Subject (add attributes above)

Model ‚Üí Payment

Model ‚Üí Account

Model ‚Üí Context

Don‚Äôt hook them to services yet ‚Äì just define names + types.

Step 2 ‚Äì Integration wrapper

Create attributes under Integration (or Raw) for all real backends, e.g.:

Integration.Payments.PaymentRequest

Resolver ‚Üí your payment service / request JSON

Integration.Accounts.AccountDetails

Resolver ‚Üí existing ‚ÄúSearch Arrangements / Account to Card and Customer Extended‚Äù service

Integration.Auth.AccessToken

Resolver ‚Üí token claims (subject type, tenancy, profiles, etc.)

Step 3 ‚Äì Mapping Integration ‚Üí Model

Use processors or scripts:

Model.Subject.type

Parent: Integration.Auth.AccessToken

Logic: map ‚ÄúIB User‚Äù ‚Üí IB_USER, etc.

Model.Subject.tenancy

From token claim ‚ÄúUser Id Tenancy‚Äù

Model.Subject.channelAccessProfiles[]

From token/entitlement system

Model.Subject.paymentAccessProfiles[]

From token/entitlement system

Model.Payment.type

Parent: Integration.Payments.PaymentRequest

Map JSON paymentType ‚Üí enum.

Model.Account.channelVisibilityProfiles[]

Parent: Integration.Accounts.AccountDetails

Map existing access profile data list.

Model.Context.channel

From request header or token (WEB, MOBILE).

Model.Context.actionId

Parent: request (path + method or Action URI)

Mapping table like:

action:payments/payment/cancel ‚Üí PAYMENT_CANCEL

Now your policy layer never sees raw JSON, URIs or service names.

4. Build named conditions from the doc text

Translate the English rule into reusable conditions.

Identification

User Id Tenancy is Internet Banking
User access via Web channel

Named condition: IsInternetBankingWebUser

Model.Subject.tenancy == "INTERNET_BANKING"

Model.Context.channel == "WEB"

Authorization

User has Access Profile Internet Banking Channel Access
User has Access Profile Interbank OR Intrabank Access Right
Account is accessible on Access Profile Internet Banking Channel Access

Split this:

HasIBChannelAccessProfile

"IB_WEB_ACCESS" in Model.Subject.channelAccessProfiles

HasPaymentAccessProfile

Model.Subject.paymentAccessProfiles contains any of ["INTERBANK", "INTRABANK"]

AccountVisibleOnIBChannel

"IB_WEB_ACCESS" in Model.Account.channelVisibilityProfiles

Decision call (payment type list)

Payment Type is INTERNATIONAL OR TRANSFER OR BPAY ‚Ä¶

Named condition: PaymentTypeAllowedForIBCancel

Model.Payment.type in [INTERNATIONAL, TRANSFER, BPAY, LAT, REDRAW, MULTI_TRANSFER, PAYANYONE]

Now you have four named conditions that can be reused in other rules, not just ‚ÄúCancel Payment‚Äù.

5. Create the Payment policy in PingAuthorize
Policy set structure

In Policies:

Domain: Payments

Policy Set: IB User Payments

Policy: Authorize IB User View Payment

Policy: Authorize IB User Create Payment

Policy: Authorize IB User Cancel Payment

Policy: Deny Otherwise

Example: ‚ÄúAuthorize IB User Cancel Payment‚Äù

Target for this policy (so it only runs for the right operation):

Model.Subject.type == "IB_USER"

Model.Context.actionId == "PAYMENT_CANCEL"

Rule 1 ‚Äì Permit

Condition = all of:

IsInternetBankingWebUser

HasIBChannelAccessProfile

HasPaymentAccessProfile

AccountVisibleOnIBChannel

PaymentTypeAllowedForIBCancel

Effect: PERMIT

Rule 2 ‚Äì Default Deny (in same policy set or global)

If no previous PERMIT ‚Üí DENY (with denied-reason obligation if you want).

Notice how:

No rule mentions ‚ÄúADR User‚Äù, ‚ÄúIB User‚Äù strings, action URIs, PIP names, or payment service names.

Everything is expressed via Model.* attributes + named conditions.

6. How to migrate from the existing matrix

Freeze the matrix as documentation of current behaviour.

For each row (subject + operation + action URI + primary object):

Define:

Model.Subject.type (IB_USER / ADR_USER / BANKER / ‚Ä¶)

Model.Context.actionId (ACCOUNT_VIEW / PAYMENT_CANCEL / ‚Ä¶)

Model.Account or Model.Payment as primary model entity.

For each ‚ÄúAuthorize: ‚Ä¶‚Äù document:

Decompose it into:

Subject conditions (tenancy, profiles) ‚Üí Model.Subject.* + named conditions.

Resource conditions (account visible, payment type) ‚Üí Model.Account.*, Model.Payment.*.

Context conditions (channel, web/mobile) ‚Üí Model.Context.*.

Implement model + integration mapping as in sections 2‚Äì3.

Build new Payments v2 or IB User Payment policy sets that:

Target by Model.Subject.type + Model.Context.actionId,

Use only named conditions over Model.*.

Behind the scenes, keep your old policy sets for now and use:

A toggle or environment config to route some traffic to the new policy sets first (DEV / UAT), then progressively more, then all.

If you want, next I can:

Take one more row from that matrix (e.g. ‚ÄúIB User View Payment‚Äù or ‚ÄúBanker Order Statement‚Äù) and write out the exact Model.* attributes & Ping policy tree so you can literally mirror it in the editor.

You said:
shouldnt't thse be context instead of subjet model?Model.Subject.type ‚Üí IB_USER, ADR_USER, BANKER, WHITE_LABEL_USER, ‚Ä¶

Model.Subject.tenancy ‚Üí INTERNET_BANKING, OPEN_BANKING, etc.

Model.Subject.channelAccessProfiles[] ‚Üí e.g. ["IB_WEB_ACCESS", "IB_MOBILE_ACCESS"]

Model.Subject.paymentAccessProfiles[] ‚Üí ["INTERBANK", "INTRABANK"]
ChatGPT said:

Great question ‚Äî and it shows you‚Äôre thinking at the right architectural level.

Short answer:

No ‚Äî those specific items do belong in Model.Subject, not in Model.Context.
But let me explain the mental model so it becomes 100% clear.

‚úÖ The golden rule for ABAC modelling
SUBJECT = "Who the actor is"
CONTEXT = "How/where the action is happening right now"

That‚Äôs the boundary.

‚úî Why IB_USER, ADR_USER, BANKER, WHITE_LABEL_USER belong in Subject

These terms represent identity classification, not runtime request context.

They identify what kind of person/system the user is

They do not change per request

They come from identity sources (IdP, directory, HRMS, access profile systems)

They describe entitlements the user holds globally, not per-request metadata

Therefore:
Model.Subject.type = "IB_USER" is identity.

It should never be in Context because Context is per-request ephemeral state, not identity.

‚úî Why Model.Subject.tenancy is also Subject

TENANCY = INTERNET_BANKING / OPEN_BANKING / WHITE_LABEL
This is:

a user domain,

a coarse-grained classification of who this person is,

usually fixed for the user session,

often embedded in the access token / SSO claims.

This definitely belongs under Subject.

‚úî Why Model.Subject.channelAccessProfiles[] belong in Subject

Examples:

"IB_WEB_ACCESS"

"IB_MOBILE_ACCESS"

"INTERBANK_ACCESS_RIGHT"

"INTRABANK_ACCESS_RIGHT"

These are permissions or entitlement bundles assigned to the user.

They are not context because:

They do not tell you where the user is coming from (that is context).

They tell you what the user is allowed to do across all channels.

They are static until changed by entitlement systems.

Thus they belong in:

Model.Subject.channelAccessProfiles[]
Model.Subject.paymentAccessProfiles[]


They are capabilities, not context.

üìå So what goes in Context?

Context contains ONLY things that can change per request.

Examples that correctly belong in Context:

(1) Channel of access (runtime request)

WEB

MOBILE

API

BRANCH_TERMINAL

CALL_CENTER

This belongs in:

Model.Context.channel

(2) Device, IP, network, geo

Model.Context.deviceId

Model.Context.ipCountry

Model.Context.sessionRiskScore

Model.Context.isTrustedDevice

(3) Action being performed

Model.Context.actionId ‚Üí PAYMENT_CANCEL, ACCOUNT_VIEW, etc.

(4) Toggles, A/B switches

Model.Context.featureFlags[]

(5) Payment parameters passed in the request

some also belong in Model.Payment.*, but metadata like timestamp belongs in Context.

üß† Think of it like this:
SUBJECT answers:

‚ÄúWho is this actor in our identity & entitlement world?‚Äù

CONTEXT answers:

‚ÄúWhat is the environment of this specific request?‚Äù

They are orthogonal.

üîç Concrete Example From Your Screenshot

Your old policy says:

Identification:
  User Id Tenancy is Internet Banking
  AND User access via Web channel


Mapped to the new model:

Old Phrase	New Attribute	Why?
User Id Tenancy is Internet Banking	Model.Subject.tenancy == "INTERNET_BANKING"	identity-level property
User access via Web channel	Model.Context.channel == "WEB"	per-request contextual property

Perfect split.

üí° If you moved these to Context, things break.
For example:

If Model.Subject.type were in Context‚Ä¶

A malicious request could fake "type": "BANKER" in a header.

You lose identity integrity.

You confuse the boundary between identity and request metadata.

Same for access profiles ‚Äî they are not runtime properties.

üß± Final recommended structure
‚úî SUBJECT (identity-based)
Model.Subject.type
Model.Subject.tenancy
Model.Subject.roles[]
Model.Subject.channelAccessProfiles[]
Model.Subject.paymentAccessProfiles[]
Model.Subject.customerSegment
Model.Subject.employmentOrgUnit
Model.Subject.kycStatus
Model.Subject.riskRating
...

‚úî CONTEXT (request-based)
Model.Context.channel
Model.Context.actionId
Model.Context.deviceId
Model.Context.ipAddress
Model.Context.authStrength
Model.Context.riskScore
Model.Context.featureFlags[]
Model.Context.timestamp
...

‚úî PAYMENT/ACCOUNT/CUSTOMER (resource-based)
Model.Payment.*
Model.Account.*
Model.Customer.*
...

‚≠ê TL;DR (Easy Rule)

If the attribute describes the person, their entitlements, or their classification,
‚Üí SUBJECT

If the attribute describes this request, this device, this action, or this moment,
‚Üí CONTEXT

If you want, I can now:

üëâ Rewrite your entire ‚ÄúIB User Cancel Payment‚Äù policy into Model.Subject + Model.Context + Model.Payment properly
üëâ Draw the final recommended folder structure for PingAuthorize (Model, Integration, Conditions, Policies)
üëâ Show how to convert your matrix of rows (IB User View, ADR User Create, Banker Order‚Ä¶) into a modern ABAC model

Just tell me which one you want next.

You said:
what if integration involves multiple pips
ChatGPT said:
Thought for 12s

Good question ‚Äì multiple PIPs is normal, and it actually fits really nicely with the ‚ÄúModel / Integration‚Äù pattern we‚Äôve been building.

I‚Äôll show you how to wire multiple PIPs without re-coupling policies, in PingAuthorize terms.

1. Core principle

Even with multiple PIPs:

Policies still only see Model.*.
Each Model.* attribute is free to use one or many Integration/PIP sources behind the scenes.

So we just change how we build Model.*, not how policies use it.

2. Patterns for multiple PIPs

Assume we want to build Model.Account and data lives in:

PIP 1 ‚Äì Core banking service (balances, status, product)

PIP 2 ‚Äì CRM (segment, RM, marketing flags)

PIP 3 ‚Äì Limits service (online limits, approval tiers)

2.1 One Integration attribute per PIP

In Attributes ‚Üí Integration:

Integration.Account.CoreResponse

Resolver ‚Üí Service: CoreBankingAccountService

Integration.Account.CrmResponse

Resolver ‚Üí Service: CrmAccountService

Integration.Account.LimitsResponse

Resolver ‚Üí Service: AccountLimitsService

Each is just a ‚Äúraw JSON blob‚Äù wrapper around one PIP.

2.2 Model attributes pull from multiple Integration attributes

Now, in Model.Account:

Model.Account.status

Parent: Integration.Account.CoreResponse

Script: read status code from core JSON, map ‚Üí ACTIVE/BLOCKED/CLOSED.

Model.Account.segment

Parent: Integration.Account.CrmResponse

Script: read CRM segmentation field, normalise.

Model.Account.dailyOnlineLimit

Parent: Integration.Account.LimitsResponse

Script: read limit field.

Policies see:

Model.Account.status
Model.Account.segment
Model.Account.dailyOnlineLimit


They never know (or care) that three different PIPs were called.

3. When you need to merge multiple PIPs for one attribute

Sometimes one logical field comes from multiple PIPs, e.g.:

Risk info from Fraud Engine and AML Engine

Entitlements from IdP claims and Entitlements API

Pattern:

Create separate raw attributes:

Integration.Risk.FraudScoreResponse

Integration.Risk.AmlScoreResponse

Create a derived Integration ‚Äúcombined‚Äù attribute:

Integration.Risk.CombinedScore

Script logic example:

fraud = get(FraudScoreResponse.score)
aml   = get(AmlScoreResponse.score)

// Whatever your rule is
return max(fraud, aml)


Then map Model.Context.riskScore from only Integration.Risk.CombinedScore.

So you still stay with:

Context.riskScore  ‚Üê  Integration.Risk.CombinedScore
                      ‚Üê  (Fraud + AML PIPs)


Policies only use Model.Context.riskScore.

4. Using multiple resolvers on one attribute (Ping feature)

PingAuthorize also lets you put multiple resolvers on a single attribute with conditions / priority.

You can use that for ‚Äúfallback‚Äù behaviour:

Example: Integration.Customer.ProfileResponse:

Resolver 1 ‚Üí primary CustomerProfileService

Resolver 2 ‚Üí fallback LegacyCustomerService

Optionally, a condition so resolver 2 only runs if 1 fails / is null.

Then Model.Customer.* is built from Integration.Customer.ProfileResponse and doesn‚Äôt care which backend produced it.

Use this pattern when:

two PIPs provide ‚Äúthe same conceptual data‚Äù,

you‚Äôre migrating from old ‚Üí new,

or you need an emergency fallback.

5. Caching & performance with multiple PIPs

When you start calling several PIPs:

Cache at Integration level

Set TTL / scope on Integration.* attributes (like you already do).

So if multiple Model.* fields use the same JSON, it‚Äôs fetched once.

Don‚Äôt re-call PIPs in policies

All calls happen in resolvers/attributes.

Policies only do comparisons on Model.* values (cheap).

Be explicit which PIPs are per-request vs per-session

e.g. risk scores are per request ‚Üí short TTL.

entitlements from IdP might be per session ‚Üí longer TTL or straight from token.

6. Concrete mini-example (payment cancel with 3 PIPs)

Say you want to decide ‚ÄúCan IB User cancel this payment?‚Äù using:

PIP A: Auth/IdP ‚Üí user type, profiles

PIP B: PaymentService ‚Üí payment type, status

PIP C: AccountService ‚Üí debit account owner + visibility

Integration layer:

Integration.Auth.AccessToken

Integration.Payments.PaymentDetails

Integration.Accounts.AccountDetails

Model layer:

Model.Subject.* ‚Üê from Integration.Auth.AccessToken

Model.Payment.* ‚Üê from Integration.Payments.PaymentDetails

Model.Account.* ‚Üê from Integration.Accounts.AccountDetails

Model.Context.* ‚Üê from request (channel, actionId, etc.)

Policy:

Uses conditions:

IsInternetBankingWebUser (Subject + Context)

HasIBChannelAccessProfile (Subject)

AccountVisibleOnIBChannel (Account)

PaymentTypeAllowedForIBCancel (Payment)

Policy is blissfully unaware that three different PIPs were involved.

7. TL;DR: how to think about multi-PIP in your design

Never expose PIPs to policies.
All PIP usage lives under Integration.* + mapping logic.

One PIP call ‚Üí one Integration attribute, or a small cluster if needed.

Model attributes can depend on multiple Integration attributes
(and you can add an intermediate ‚ÄúCombined‚Äù attribute when you need merging).

Use multiple resolvers only when they really represent the same conceptual source with fallback or migration.

If you want, I can sketch exact attribute trees for one of your real flows like:

‚ÄúIB User Create Payment‚Äù, or

‚ÄúBanker Order Statement‚Äù

showing which Integration attributes map into which Model attributes, with 2‚Äì3 PIPs involved, so you can mirror it in Policy Editor.
